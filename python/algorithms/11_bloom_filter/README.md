## Заметка о проделанной работе

По заданию требовалось реализовать [фильтр Блюма](https://en.wikipedia.org/wiki/Bloom_filter) фиксированного размера с двумя хэш-функциями.     
Число элементов для записи - 10.

Заготовка класса:
```python
class BloomFilter:

    def __init__(self, f_len):
        self.filter_len = f_len # 32 бита по заданию
        # создать битовый массив для записи элементов
        # ...

    def hash1(self, str1):
        # расчет битовой маски по строке на входе
        # ...

    def hash2(self, str1):
        # ...

    def add(self, str1):
        # добавить строку str1 в фильтр
        # ...

    def is_value(self, str1):
        # проверка присутствия строки str1 в фильтре
        # ...
```

К целым числам в Python можно применять побитовые операции (`&`; `|`; `^`; `~`; `<<`; `>>`), что позволяет довольно лаконично запрограммировать, например, работу с битовыми масками.

В частности, именно с ними возникла основная трудность. Ранее мне не приходилось использовать побитовый сдвиг, и я не сразу придумал создавать маску с его помощью. Благодаря работе над заданием в целом стал лучше понимать тему побитовых операций.

Поскольку обе хэш-функции рассчитывают битовую маску от строки схожим образом, для соблюдения принципа "DRY" заготовку класса расширил дополнительными методами (см. [файл решения](https://github.com/d-tsygolnik/exercises/blob/main/python/algorithms/11_bloom_filter/bloom.py)):
- расчет индекса по заданной строке и произвольному числу (повторяющийся код);
- подготовка битовой маски по индексу (реализован отдельно для улучшения ясности кода).

С написанием методов `add()` и `is_value()` трудностей не возникло.
