## Поиск решения

#### Дано

- время преодоления дистанции без остановок;
- данные для светофоров, N, [location, red_time, green_time]:
    - N - кол-во светофоров;
    - расстояние от начала пути до каждого светофора;
    - интервалы горения красного и зеленого света (цикл начинается с красного).

#### Требуется рассчитать    
Общее время в пути `Т = (L + X)`, где:    
Х - суммарная продолжительность остановок на светофорах

### Рассуждения 

При начале отсчета начинается движение из начал в конец и запускаются циклы смены сигналов светофоров, начиная с красного (R).
Для каждого отдельного светофора возможны 2 ситуации:
1) автомобиль попадает на красный сигнал и ожидает смены сигнала на зеленый;
2) автомобиль попадает на зеленый сигнал и двигается без остановки до сл. светофора.
```
    RRRGGGRRRGGG
    ---+--------
    ----+-------
    -----+------ попадаем на зеленый при (T%(R+G)==0 или R<(T%(R+G)<(R+G)
    ------*-----
    -------*----
    --------*--- попадаем на красный при (T%(R+G)<=R 

    --3--------
    ------7----
    -----------12
```
"Если впереди остаются светофоры" -- остаться в цикле перебора списков [location, R, G].    
"Светофоров не осталось" -- выйти из цикла.

Текущая позиция:    
`Т = расстояние от начала пути до 1-го светофора + сумма промежутков между сл. светофорами + остановки`

**Псевдокод решения**

```
стоим на старте:
   #> T = 0
   #> loc_prev = 0
поехали -- начали перебор светофоров (входим в цикл):
   #> loc_curr = i[0] # loc i-го светофора
   #> если попали на красный: !! попадаем на красный уже проехав расстояние от предыдущего светофора до текущего
       #> увеличиваем время в пути на время остановки -- остаток горения красного сигнала
   #> если на зеленый:
       #> общее время в пути дополнительно не увеличиваем
   #> увеличиваем общее время на расстояние от предыдущей точки до текущего положения -- `T += loc_curr - loc_prev`
   #> оставили светофор позади -- `loc_prev = loc_curr`
светофоры кончились (вышли из цикла):
   #> остается проехать остаток расстояния без остановок ==> `T += L - loc_prev`
   #> выводим общее время в пути T
```

**Решение**

```python
# v.1
def Unmanned(distance, num_traffic_lights, track): # track [[light_location, time_red, time_green], [], ...]
    T = 0 # total time
    prev_light_location = 0
    for i in track:
        curr_light_location = i[0]
        time_red = i[1]
        time_green = i[2]
        T += curr_light_location - prev_light_location 
        if (T % (time_red + time_green)) <= time_red: # В случае остановки
            T += time_red - (T % (time_red + time_green))
        prev_light_location = curr_light_location
    T += distance - prev_light_location 
    return T
```

v.1 -- ошибка в [тесте](https://github.com/d-tsygolnik/exercise/blob/934037336d5033f4543ab910f6987663db58b2d7/python/00_simple/ex_14/test_ex_14.py#L11): 14 != 10

**Предположительное решение**    
Нужно учесть вариант, когда светофоры даны, но путь до пункта назначения короче. Светофоры перебираем, но если `location > L`, переходим к сл. светофору, пропуская текущий.

**Решение**

```python
# v.2
def Unmanned(distance, num_traffic_lights, track): # track [[light_location, time_red, time_green], [], ...]
    T = 0 # total time
    prev_light_location = 0
    for i in track:
        if i[0] > distance:
            continue
        else:
            curr_light_location = i[0]
            time_red = i[1]
            time_green = i[2]
            T += curr_light_location - prev_light_location 
            if (T % (time_red + time_green)) <= time_red: # В случае остановки
                T += time_red - (T % (time_red + time_green))
            prev_light_location = curr_light_location
    T += distance - prev_light_location 
    return T
```
