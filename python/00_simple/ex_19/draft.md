
Названия товаров -> data_mess=[str1, str2, ..., strN]

платье1 5
сумка32 2
платье1 1
сумка23 2
сумка128 4

Задача:
- объединить повторяющиеся имена и суммировать кол-во

    ```
    -- before --
    платье1 5
    платье1 1

    -- after --
    платье1 6

    Варианты реализации
    -- вар. 1 --

    создать пустой словарь items = {}
    for i in data_mess: # идем по списку строк data_mess, и далее для каждой
        curr_val = data_mess[i].split() # curr_val=[item, amount]
        if curr_val[0] not in items:
            items[curr_val[0]] = curr_val[1] # если item попалось первый раз, добавляем в словарь
        items[curr_val[0]] += curr_val[1] # прибавляем текущее amount к общему кол-во
    ----
    ```
    
            

- получить из пар [item, amount], содержащихся в словаре, строки вида 'item amount'
- сформировать отсортированный в порядке убывания amount список пар data_templ=[[pair1] [pair2] ... [pairM]] 

- пройти по data_templ, проверяя amount:
    
    ```
    -- source: ряд items с одним amount не отсортирован по в порядке лексикографического возрастания --
    платье1   6
    сумка128  4
    сумка32   2 < 
    сумка42   2 < 
    сумка23   2 <
    часы1     1

    платье1   6
    сумка128  4
    сумка23   2 <
    сумка32   2 < 
    сумка42   2 < 
    часы1     1
    ```

```
cnt = 0
while cnt < len(data_templ):
    # curr_amount compare with next_amount
    # если совпали:
        запоминаем индекс начала цепи -- head=cnt
        идем по цепи, собирая в отдельный список -- пока сл. amount == текущему: ... cnt += 1
        в конце цепи запоминаем последний индекс -- 
        сортируем списк
        надо заходить в цепочку -- 
unsorted = ['сумка23', 'сумка32', 'сумка42']

```
- записать полученные строки в список data_ordered=[str1, str2, ..., strN]
- отсортировать элементы 
- сгруппировать items 
