## Задача

Максимально компактно закодировать текстовый редактор, выполняющий следующие операции:
1. Добавить(S) -- в конец текущей строки (исходно пустая) добавляется строка S;
2. Удалить(N) -- удалить N символов из конца текущей строки. Если N больше длины текущей строки, удаляем из неё все символы;
3. Выдать(i) -- выдать i-й символ текущей строки (индексация начинается с нуля) в формате строки (строковый тип). 
Если индекс за пределами строки, возвращайте пустую строку;
4. Undo() -- отмена последней операции 1 или 2; отмена должна уметь выполняться при необходимости неограниченное число раз;
5. Redo() -- выполнить заново последнюю отменённую с помощью Undo операцию; Redo должна уметь выполняться при необходимости неограниченное число раз.
Если после Undo выполняется операция 1 или 2, то: 
-- предыдущая цепочка операций для Undo обнуляется (откатить можно только последнюю операцию 1 или 2);
-- Redo более становится нечего откатывать.

На вход редактора подаётся одна строка в формате: <номер операции (1-5)> <пробел> <параметр операции, если нужен>.

Таким образом, варианты команд на вход:

`1 Привет` -- добавляем 'Привет' в конец текущей строки

`2 5` -- удалить 5 символов из конца текущей строки

`3 5` -- выдать символ по индексом 5 из текущей строки

`4` -- отменить последнее действие
`5` -- выполнить заново последнее отмененное действие

Реализовать редактор в виде функции `BastShoe(command_string)`.

Функция получает на вход строку в формате "N параметр", где N -- код операции (1-5), в зависимости от которого возвращает:
- текущую строку;
- если команда Выдать(N): 
    - символ в формате строки; 
    - пустую строку в случае ошибки команды (N > len(curr_str));
- если команда задана некорректно, возвращается текущую строку без изменений.

Например, BastShoe("1 Привет") --> "Привет", т.е. текущей строкой стало "Привет", а в список слежения Undo=['1 Привет']

---

Пока что главный вопрос: каким образом хранится текущая строка и логи (undo, redo), если BastShoe() предполагает одно действие за раз?

т.е. операции вроде как локальные, при этом каждая влияет на строку, которая существует вне функции BastShoe(). Но при этом возврат этой строки нужно реализовать в рамках BastShoe().

Единственным решением здесь видится создание глобальных переменных наряду с функцией.

---

### Расширенный образец работы программы

```
1 Привет 
В текущей строке будет "Привет"

1  , Мир!
Привет, Мир!

1 ++ 
Привет, Мир!++

2 2
Привет, Мир!

4
Привет, Мир!++

4
Привет, Мир!

1 *
Привет, Мир!*

4
Привет, Мир!

4 
Привет, Мир!

4
Привет, Мир!

3 6
,

2 100
<пустая строка>

1 Привет 
Привет

1  , Мир!
Привет, Мир!

1 ++ 
Привет, Мир!++

4
Привет, Мир!

4
Привет

5
Привет, Мир!

4
Привет

5
Привет, Мир!

5
Привет, Мир!++

5
Привет, Мир!++

5
Привет, Мир!++

4
Привет, Мир!

4
Привет

2 2
Прив

4
Привет

5
Прив

5
Прив

5
Прив

```

### Заметки по решению

#### начало - проверка корректности вводимой команды

разделение команды на код и параметр; код и параметры разделяются пробелом (предполагаю, что м.б. произвольное число)
коды cmd_ids=[1, 2, 3, 4, 5]
если команда задана некорректно, возвращается текущая строка без изменений.


в каких случаях команда может считаться некорректной?

- первая цифра в command не содержится в cmd_ids
- command начинается не с цифры
- любые символы после id=4;5, кроме пробелов

```python
curr_str = '' # нужно создать строку, над которой будут производиться операции

def BastShoe(command):

    def cmd_check(command):
        cnt = 0
        cmd_ids = ['1', '2', '3', '4', '5']
        id_templ = ''
        for i in command:
            if cnt > 1:
                break
            id_templ += i
            cnt += 1
        # здесь должно получиться, например '1 '/'4'/'66'/'xd'
        id_test = id_templ.split()
        if id_test[0] not in cmd_ids: # команда задана неверно
            return None 
        else:
            return id_test[0] # выводим id команды

    curr_id = cmd_check(command)
    if curr_id == None:
        return curr_str
    else:
        # смотрим по конкретному id
```

#### Проверка по id

id = 2;3

```python

# command в этом случае представлена одним из вариантов:
# ok : id_N / id_____N / id_N______  ('_' - это пробел)
    # в этом случае command.split() создаст список из двух значений; доп. проверки потребует N (должно быть число)
# error: id_ / id_N_abcd / id_abcd
    # в этих случаях длина command.split() не равна 2

считываем command
if len(command.split()) == 2: # проверка на корректность команды с id=2;3
    # проверяем N
    N = command.split()[1]
    if str_is_number(N): # обращаемся к операции, в зав-ти от id
        N = int(N)
        # method for id
        if curr_id == '2' and N >= 0: # удалить N символов из конца текущей строки. Если N больше длины текущей строки, удаляем все символы;
            if N >= len(curr_str):
                curr_str = ''
            else:
                curr_str = curr_str[:len(curr_str)-N]
        if curr_id == '3' and N >= 0: #  выдать i-й символ текущей строки (индексация начинается с нуля) в формате строки (строковый тип). 
                    #Если индекс за пределами строки, возвращайте пустую строку;
            if N > len(curr_str)-1:
                return ''
            else:
                return curr_str[N]
return curr_str # возвращаем текущую строку, т.к. команда содержит некорректный запрос
```

id = 4;5

```python
```

---

Задача оценить команду на корректность до вызова методов, в отдельном блоке

```
Критерии корректности:
1. Строка начинается с id=1;2;3;4;5, за которым идет пробел или конец строки --> command.split()[0] in ['1', '2', '3', '4', '5']
2. В зав-ти от id
    id=1 : ---- текущая строка выдается в любом случае
    ----
    Корректное выполнение --> вызвать метод, выдать текущую (обновленную) строку
    id_abcd
    id_____abcd
    id_N
    id_____N
    id_N______  
    id_N_abcd
    Ошибка --> выдать текущую строку
    id / id_

    id=2
    ----
    Корректное выполнение --> вызвать метод, выдать текущую (обновленную) строку
    id_N
    id_____N
    id_N______  
    Ошибка --> выдать текущую строку


Возможные варианты

прим.: '_' - это пробел


id_N
id_____N
id_N______  

id
id_

id_N_abcd


В любом случае

```
