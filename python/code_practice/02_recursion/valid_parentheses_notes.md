
Сразу понял, что нужно рассматривать только четные наборы скобок `len(par_array) % 2 == 0`    
"Железный" кретерий №1.

---

Далее была идея использовать два стека. Почему? - В валидных строках на каждую открывающую найдется закрывающая. Идея добавлять скобки "(" в один стек, а ")" в другой, и сравнивать длину стека -- не работает из-за нарушения порядка (некорректный результат в случае ")(", например).

---

Идея присваивать "(" значение +1, ")" -1 и выводить результат на основе суммы -- тоже не всегда корректный результат ("()" +- выдает False, хотя комбинация валидная).

Первичная версия решения:
```python
def valid_parentheses(string):
    parentheses = []
    parentheses_cnt = 0
    for c in string.strip(): # пройти по строке, собрать скобки
        if c in "()":
            parentheses.append(c)
            parentheses_cnt += 1
    if parentheses_cnt != 0 and parentheses_cnt % 2 == 0:
        valid_marker = 1
        for p in parentheses:
            if p == ")":
                valid_marker *= -1
        if valid_marker == 1:
            return True
    return False
```
Некорректно обрабатывается как случай "()".

---

Провел дополнительные наблюдения, рассмотрев все комбинации из 2, 3 и 4 скобок. Обратил также внимание на некоторые наборы из 6 скобок.

Выделил второе условие, по которому невалидные комбинации отсеиваются в самом начале - первая и последняя скобка должны образовывать исключительно валидную пару.     
"Железный" кретерий №2.

Далее заметил, что валидные комбинации образуются при наличии частного случая невалидной пары ")(" внутри валидных скобок.    
Появилась догадка, что скобки нужно проверять попарно, отслеживая номер итерации. Наблюдения уводят к решению с помощью рекурсии.

Заготовку решения получил на бумаге, поочередно рассматривая наборы скобок по 2, 4, 6.    
Попарная проверка пар скобок начинается в исходной строке, которая сокращается на каждом шаге итерации, если первая пара скобок валидна. Таким образом, предельный случай - это 1 пара скобок, после проверки которой рекурсивные вызовы прекращаются.

Дополнительные наблюдения показали, что нужны счетчики количества валидных и невалидных, только ")(", пар. В зависимости от числа шагов итерации, валидность всего набора зависит от отношения значений в данных счетчиках.

Псевдокод
```
def main_func(string):
    собрать скобки в список
    если длина списка нечетная:
        return False
    return iter_func(шаг_итерации, всего_шагов, скобки, всего_валидных, всего_невалидных)

def iter_func(шаг_итерации, всего_шагов, скобки, всего_валидных, всего_невалидных):
    записываем комбинацию пары скобок в переменную curr_pair
    проверка номера итерации -- если шаг=1, т.е. проверка внешней пары скобок:
        if curr_pair != "()": # пара невалидная
            return False # бракуем по второму "железному" критерию
        если всего_шагов == 1: # скобок всего 2, и они валидные ==> вернуть окончательный ответ
            return True
        # переход к сл. итерации
        # исключаем из рассмотрения проверенные скобки
        # обновляем счетчик валидных пар
        return iter_func(шаг_итерации+1, всего_шагов, скобки[1:-1], всего_валидных+1, всего_невалидных)
    # действия на втором и последующих шагах итерации
    если curr_pair не "()" и не ")(":
        return False # т.к. скобок четное кол-во, то "(" и ")" должно быть строго поровну
    if curr_pair == "()":
        valid_num += 1
    else:
        invalid_num += 1
    если шаг_итерации не последний:
        # переход к сл. итерации
        # исключаем из рассмотрения проверенные скобки
        # используем текущие значения счетчиков валидных и невалидных пар
        return iter_func(шаг_итерации+1, всего_шагов, скобки[1:-1], всего_валидных, всего_невалидных)
    # иначе, на последнем шаге проводим анализ соотношения числа валидных и невалидных пар
    если при четном числе шагов итерации:
        if valid_num > invalid_num:
            return True
        return False
    # иначе, при нечетном числе шагов
    if valid_num < invalid_num:
        return False
    return True
```

Некорректно отрабатывает в случае "()()"
Ошибка в блоке:
```python
    # иначе, на последнем шаге проводим анализ соотношения числа валидных и невалидных пар
    if iter_steps_num % 2 == 0: # если при четном числе шагов итерации:
        if valid_num > invalid_num:
            return True
        return False
```
Еще раз обратился к наблюдениям. Оказывается, не углядел ранее, и нужно `>=`.
Исправил, результат теста корректный.

Нужно больше тестов.

Поправил основную функцию, чтобы пустая строка, когда нет скобок, была валидной.

Ошибки в тестах:
parens = '((())()())'
False should equal True

parens = '(c(b(a)))(d)' -- '((()))()'
False should equal True

parens = 'isdof()(vdcq(q)f)e((ig)qem)xxpxm' -- '()(())(())'
False should equal True

Обязательно четное кол-во скобок
Обязательно валидные скобки на первом шаге
Строго поровну открывающих и закрывающих скобок с шага 2 по последний, и порядок не важен?

'( )(())(() )'
усл1 +
усл2 +
(4 )4 усл3 +

'( )())(( )'
усл1 +
усл2 +
убрал одну ( +
убрал одну ) +
(3 )3 усл3 + По-прежнему набор валиден? - Нет. Как так вышло? - Как-то нарушился исходный порядок.

```
'( )(())(() )' было
   )      ) невал -- вал >> невал строго
    (    (  вал -- невал >> невал строго
     (  (   вал -- невал >> невал строго
      ))    невал -- вал >> невал строго

'( )-())((- )' стало
   )     (  невал -- невал >> невал НЕстрого
     (  (   вал -- невал   >> невал строго 
      ))    невал -- вал   >> невал строго
```

Заметим, что исходно строго невалидных пар четное число.
После удаления пары "()" из произвольных позиций строго невалидных осталось по-прежнему четное, но возникла 1 НЕстрого невалидная пара.

Что, если повторить удаление из произвольной позиции?
```
'( )())(( )' было
   )    (  невал -- невал >> невал НЕстрого
   >(  (   вал -- невал   >> невал строго 
     ))<    невал -- вал   >> невал строго

'( )-)-(( )' стало
   )    (  невал -- невал >> невал НЕстрого
     ) )   невал -- вал   >> невал строго
```
В таком случае получаем невалидную комбинацию, т.к. 


...
если невалидных на шагах 2 по последний набирается четное (любого типа ?)

пока что получал только по паре строгих, попробую с НЕстрого валидными:
```
'( )())(( )' было
   )    (  невал -- невал >> невал НЕстрого
   >(  (   вал -- невал   >> невал строго 
    >))     невал -- вал   >> невал строго

'( )--)(( )' стало
   )    (  невал -- невал >> невал НЕстрого
      )(   невал -- невал >> невал НЕстрого
```
Получается невалидная комбинация
Получилась бы валидная, если бы невалидных и валидный пар было бы поровну -- "( () )( () )"

А как будет со строго невалидными?
```
'( )(())(() )' было >> валидно
  >)     >) невал -- вал >> невал строго
    (    (  вал -- невал >> невал строго
     (  (   вал -- невал >> невал строго
      ))    невал -- вал >> невал строго

'( -(())((- )' стало >> невалидно
    (    (  вал -- невал >> невал строго
     (  (   вал -- невал >> невал строго
      ))    невал -- вал >> невал строго

если удалить еще одну строго невалидную пару?
'( -(())((- )' было >> невалидно
    (    (  вал -- невал >> невал строго
     (  (   вал -- невал >> невал строго
     >))<   невал -- вал >> невал строго

'( -(())((- )' было >> невалидно
    (    (  вал -- невал >> невал строго
     (  (   вал -- невал >> невал строго
     >))<   невал -- вал >> невал строго

```

Судя по всему, получается так:

усл1: строго поровну "(" и ")"
усл2: валидная пара на первом шаге итерации
усл3: для любой валидной комбинации, во множество пар с шагов 2 по последний, должны входить:
        - либо только ")(" и "()", причем число ")(" меньше либо равно "()";
        - либо только "()" и строго невалидные пары "((" и "))", причем невалидных пар должно быть кратное число, и это число больше кол-ва "()" на 2^n, где n=0,1,2,...
        - либо ")(", "((" и "))", причем строго невалидных пар должно быть кратное число, и это число больше кол-ва ")(" на 2^n, где n=0,1,2,...

        - либо только из валидных пар "()".
(()))(()()
((())()))(((())(() v1 sn5 n3 - ((())())((())(() v1 sn5 n2 - ((())()(())(() v1 sn5 n1 - (())()))(((())() v1 sn3 n3 -
т.е. усл3.2 - кратность точно


(())()() v1 sn2 n1 + усл3.3, разница 2^0
(()))(()() v1 sn2 n2 + усл3.3, разница 0 != 2^0 или sn < n
(()))(()() v1 sn2 n2 - усл3.3, разница 0 != 2^0
(()()))(()(()) v2 sn2 n3 - усл3.3, разница 0 != 2^0

Псевдокод вспомогательной функции с учетом поправок в критериях проверки:
```
def iter_func(valid_pairs_num, invalid_pairs_num, strict_invalid_pairs_num, num_curr_step, string):
    если строка пустая:
        # анализируем результаты (счетчики пар)
        # 3.4
        if invalid_pairs_num == 0 and strict_invalid_pairs_num == 0:
            return True
        if invalid_pairs_num != 0:
            # 3.1
            if strict_invalid_pairs_num == 0:
                if invalid_pairs_num <= valid_pairs_num:
                    return True
                return False
            # 3.3?
            if strict_invalid_pairs_num % 2 == 0 and \
               strict_invalid_pairs_num > invalid_pairs_num:
                return True
            return False
        # 3.2
        if strict_invalid_pairs_num % 2 == 0 and \
           strict_invalid_pairs_num > valid_pairs_num:
            return True
        return False

    для непустой строки подготовить текущую пару для проверки
    если первый шаг итерации:
        если пара невалидная:
            return False
        если имеется всего одна пара скобок:
            return True
        # иначе переходим к сл. шагу итерации
        return iter_func(valid_pairs_num+1 # обновляем счетчика валидных пар \
                         invalid_pairs_num, strict_invalid_pairs_num, # невалидных пар пока нет \
                         num_curr_step+1, # обновим счетчик, чтобы далее не проверять это условие \
                         string[1:-1]) # исключаем проверенную пару скобок из рассмотрения 
    # на остальных шагах считаем пары "()", ")(", "((", "))"
    if curr_pair == "()": # увеличиваем счетчик валидных
        return iter_func(valid_pairs_num+1, invalid_pairs_num, strict_invalid_pairs_num, num_curr_step+1, string[1:-1])
    if curr_pair == ")(": # увеличиваем счетчик невалидных
        return iter_func(valid_pairs_num, invalid_pairs_num+1, strict_invalid_pairs_num, num_curr_step+1, string[1:-1])
    # иначе увеличиваем счетчик строго невалидных
    return iter_func(valid_pairs_num, invalid_pairs_num, strict_invalid_pairs_num+1, num_curr_step+1, string[1:-1])

```



Код для функции остается практически прежним.     
Единственное, перенесу проверку пустой строки в предельный случай рекурсии.      
Также понадобится изменить параметры вспомогательной функции.
```
def valid_parentheses(string):
    parentheses = []
    left_paren_num = 0
    right_paren_num = 0
    for c in string.strip(): # пройти по строке, собрать скобки
        if c in "()":
            parentheses.append(c)
            if c == "(":
                left_paren_num += 1
            else:
                right_paren_num = 0
    if left_paren_num == right_paren_num:
        iter_steps_num = parentheses_cnt // 2
        return iter_func(__заменить_параметры__)
    return False
```
