
Сразу понял, что нужно рассматривать только четные наборы скобок `len(par_array) % 2 == 0`    
"Железный" кретерий №1.

---

Далее была идея использовать два стека. Почему? - В валидных строках на каждую открывающую найдется закрывающая. Идея добавлять скобки "(" в один стек, а ")" в другой, и сравнивать длину стека -- не работает из-за нарушения порядка (некорректный результат в случае ")(", например).

---

Идея присваивать "(" значение +1, ")" -1 и выводить результат на основе суммы -- тоже не всегда корректный результат ("()" +- выдает False, хотя комбинация валидная).

Первичная версия решения:
```python
def valid_parentheses(string):
    parentheses = []
    parentheses_cnt = 0
    for c in string.strip(): # пройти по строке, собрать скобки
        if c in "()":
            parentheses.append(c)
            parentheses_cnt += 1
    if parentheses_cnt != 0 and parentheses_cnt % 2 == 0:
        valid_marker = 1
        for p in parentheses:
            if p == ")":
                valid_marker *= -1
        if valid_marker == 1:
            return True
    return False
```
Некорректно обрабатывается как случай "()".

---

Провел дополнительные наблюдения, рассмотрев все комбинации из 2, 3 и 4 скобок. Обратил также внимание на некоторые наборы из 6 скобок.

Выделил второе условие, по которому невалидные комбинации отсеиваются в самом начале - первая и последняя скобка должны образовывать исключительно валидную пару.     
"Железный" кретерий №2.

Далее заметил, что валидные комбинации образуются при наличии частного случая невалидной пары ")(" внутри валидных скобок.    
Появилась догадка, что скобки нужно проверять попарно, отслеживая номер итерации. Наблюдения уводят к решению с помощью рекурсии.

Заготовку решения получил на бумаге, поочередно рассматривая наборы скобок по 2, 4, 6.    
Попарная проверка пар скобок начинается в исходной строке, которая сокращается на каждом шаге итерации, если первая пара скобок валидна. Таким образом, предельный случай - это 1 пара скобок, после проверки которой рекурсивные вызовы прекращаются.

Дополнительные наблюдения показали, что нужны счетчики количества валидных и невалидных, только ")(", пар. В зависимости от числа шагов итерации, валидность всего набора зависит от отношения значений в данных счетчиках.

Псевдокод
```
def main_func(string):
    собрать скобки в список
    если длина списка нечетная:
        return False
    return iter_func(шаг_итерации, всего_шагов, скобки, всего_валидных, всего_невалидных)

def iter_func(шаг_итерации, всего_шагов, скобки, всего_валидных, всего_невалидных):
    записываем комбинацию пары скобок в переменную curr_pair
    проверка номера итерации -- если шаг=1, т.е. проверка внешней пары скобок:
        if curr_pair != "()": # пара невалидная
            return False # бракуем по второму "железному" критерию
        если всего_шагов == 1: # скобок всего 2, и они валидные ==> вернуть окончательный ответ
            return True
        # переход к сл. итерации
        # исключаем из рассмотрения проверенные скобки
        # обновляем счетчик валидных пар
        return iter_func(шаг_итерации+1, всего_шагов, скобки[1:-1], всего_валидных+1, всего_невалидных)
    # действия на втором и последующих шагах итерации
    если curr_pair не "()" и не ")(":
        return False # т.к. скобок четное кол-во, то "(" и ")" должно быть строго поровну
    if curr_pair == "()":
        valid_num += 1
    else:
        invalid_num += 1
    если шаг_итерации не последний:
        # переход к сл. итерации
        # исключаем из рассмотрения проверенные скобки
        # используем текущие значения счетчиков валидных и невалидных пар
        return iter_func(шаг_итерации+1, всего_шагов, скобки[1:-1], всего_валидных, всего_невалидных)
    # иначе, на последнем шаге проводим анализ соотношения числа валидных и невалидных пар
    если при четном числе шагов итерации:
        if valid_num > invalid_num:
            return True
        return False
    # иначе, при нечетном числе шагов
    if valid_num < invalid_num:
        return False
    return True
```

Некорректно отрабатывает в случае "()()"
Ошибка в блоке:
```python
    # иначе, на последнем шаге проводим анализ соотношения числа валидных и невалидных пар
    if iter_steps_num % 2 == 0: # если при четном числе шагов итерации:
        if valid_num > invalid_num:
            return True
        return False
```
Еще раз обратился к наблюдениям. Оказывается, не углядел ранее, и нужно `>=`.
Исправил, результат теста корректный.

Нужно больше тестов.

Поправил основную функцию, чтобы пустая строка, когда нет скобок, была валидной.

Ошибки в тестах:
parens = '((())()())'
False should equal True

parens = '(c(b(a)))(d)' -- '((()))()'
False should equal True

parens = 'isdof()(vdcq(q)f)e((ig)qem)xxpxm' -- '()(())(())'
False should equal True
