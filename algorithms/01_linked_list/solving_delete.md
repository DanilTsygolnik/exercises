# Linked List

## delete(val, all)

### Задача
Для связного списка реализовать метод удаления узлов по их значению. Удаление должно осуществляться в двух режимах:
1) удаление первого найденного узла с нужным значением -- all=False
2) удаление всех найденных значений в списке -- all=True

Что подразумевает задача:
- [x] 1) нужно рассмотреть возможные варианты расположения узлов в списке
- [x] 2) для каждого случая реализовать оптимальный алгоритм удаления
- [ ] 3) найти повторяющиеся фрагменты кода и объединить реализации для отдельных случаев в метод delete(self, value, all)

### Ход работы

#### Этапы 1, 2: варианты списков, псевдокод и заготовки метода

**Нужные узлы в произвольном месте списка**

```
                              *                   *    *    *
        .....| 0 -> 0 -> 0 -> 1 -> 0 -> 0 -> 0 -> 1 -> 1 -> 1 -> 0 -> 0 -> 0 ->|.....

список значений до удаления [ 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0]
список значений после удаления первого найденного [ 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]
список значений после удаления всех узлов (X = 1) [ 0, 0, 0, 0, 0, 0, 0, 0, 0]

```

**Рассуждения и псевдокод**

К моменту вызова метода:
- есть связный список, состоящий из узлов
вызов метода -- `self.delete(value, all=True)`
атрибуты связного списка:
self.head, self.tail -- объекты узлов, каждый с собственными атрибутами

- есть узлы:
self.value -- значение, по которому производится поиск под удаление
self.next -- след. узел или None

Таким образом, вызываем метод delete() для связного списка, в рамках которого реализуется процесс:

```
#> производим поиск значений узлов -- проходим по каждому узлу, проверяя node.value
#> поиск и удаление узлов по значению:
   #> нашли значение (curr_node.value == val) -- действуем по ситуации (all)
       #> если remove_all:
           #> if curr_node.next.value == val: # цепь узлов с искомым значением
               #> переход к сл. узлу, предыдущий не обновляем - от него перекинем связь через цепь
           #> else: # отдельный узел
               #> перекидываем связь от предыдущего узла на следующий за текущим (удаление)
               #> переходим на этот, следующий, узел; предыдущий не обновляем
       #> иначе:
       #    > удаляем, т.е. связываем предыдущий узел со следующим (prev_node.next = curr_node.next)
       #    > прекращаем перебор узлов
   #> не нашли -- переход к сл. узлу, обновляя предыдущий
```

**Код**

```python
# совпадения находятся внутри связного списка

def delete(self, val, remove_all=True):
    curr_node = self.head
    prev_node = None
    while curr_node is not None: # проходим по каждому узлу, проверяя node.value
        if curr_node.value == val:
            if remove_all:
                if curr_node.next.value == val:
                    curr_node = curr_node.next
                else:
                    prev_node.next = curr_node.next
                    curr_node = curr_node.next
            else:
                prev_node.next = curr_node.next
                break
        else:
            prev_node = curr_node # обновляем предыдущий узел, т.к. значение текущего не совпадает с искомым
            curr_node = curr_node.next
```

##### Вопросы

- [ ] различие между `is not` и `!=`

---

**Цепь узлов в начале списка**

```
               *    *    *
        .....| 1 -> 1 -> 1 -> 0 -> 0 -> 0 -> 0 -> |.....

список значений узлов до удаления [1, 1, 1, 0, 0, 0, 0]
список значений после удаления первого найденного [1, 1, 0, 0, 0, 0]
список значений узлов после удаления всех узлов [0, 0, 0, 0]

```

**Рассуждения**

Какие в данном случае особенности?
* `curr_node is self.head` - индикатор случая; если curr_node не self.head - это общий случай выше (узел внутри списка)
* prev_node -- None

**Псевдокод**

```
> производим поиск значений узлов -- проходим по каждому узлу, проверяя node.value
> поиск и удаление узлов по значению:
    > нашли значение (curr_node.value == val) -- действуем по ситуации (all)
      = -------------------- Операции по данному случаю ------------------------ =  
        > если `curr_node is self.head`:
            > если remove_all:
                > если значение сл. узла = val:
                    > переходим к сл. узлу
                > иначе (сл. узел != val, т.е. цепь узлов закончилась -- новое начало списка после удаления узлов)
                    > назначаем сл. узел головой списка
                    > переходим к сл. узлу
           #> иначе:
           #    > назначаем сл. узел головой списка
           #    > останавливаем перебор узлов (выходим из цикла)
      = ------------------------------------------------------------------------ =  
        > иначе:
            > ... (общий случай, см. выше?)
    > else: (не нашли)
        > переходим к сл. узлу, обновляя предыдущий
```
refactoring фрагмента
```
      = ------------------------------------------------------------------------ =  
       #> если `curr_node is self.head`:
           #> если сл. узел != val или remove_all = False:
               #> назначаем сл. узел головой
               #> если remove_all == False:
                   #> прекращаем поиск по списку (выход из цикла)
           #> переходим к сл. узлу
      = ------------------------------------------------------------------------ =  

```

**Код**

```python
# совпадения идут с головы связного списка

if curr_node is self.head:
    if curr_node.next.value != val or remove_all == False:
        self.head = curr_node.next
        if remove_all == False:
            break
    curr_node = curr_node.next

```

##### Вопросы

1. Когда назначается новая голова связного списка, нужно ли у предыдущего узла, если такой есть, сменить значение self.next на None? -- Полагаю, что нет, т.к. движение по связному списку начинает после вызова списка и обращения, в первую очередь, к его атрибутам (self.head, self.tail), а не к атрибутам узлов. 


---

**Цепь узлов продолжается до конца списка**

```
                                   *    *    *
        .....| 0 -> 0 -> 0 -> 0 -> 1 -> 1 -> 1 -> |.....

список значений узлов до удаления [0, 0, 0, 0, 1, 1, 1]
список значений после удаления первого найденного [0, 0, 0, 0, 1, 1]
список значений узлов после удаления всех узлов (X = 1) [0, 0, 0, 0]

```

**Рассуждения**

В данном случае, когда текущим узлом будет последний элемент списка, реализуется условие:
`curr_node is self.tail`, оно же `curr_node.next == None`

Т.е. по-прежнему:
1) движемся по списку, перебирая узлы
2) в какой-то момент начинает цепь узлов на удаление:
    

**Псевдокод**

```
#> движемся по списку, перебирая узлы
   #> если найдено совпадение:
    # проверяем значение сл. узла
    > если curr_node.next.value != val:
        # данный случай ==> обновляем хвост
       #> если curr_node.next.value == None:
           #> prev_node.next = None
           #> self.tail = prev_node
       #> иначе:
           #> ... # смотрим другие сценарии
   #> переходим к сл. узлу в любом случае

```

**Код**

```python
# совпадения идут с середины списка до конца
#...
curr_node = self.head
prev_node = None
while curr_node is not None: # проходим по каждому узлу, проверяя node.value
    if curr_node.value == val:
        if curr_node.next.value != val:
            if curr_node.next.value == None:
                prev_node.next = None
                self.tail = prev_node
            else:
                ... # другие сценарии
        curr_node = corr_node.next

```

---

**Цепь узлов начинается в голове списка и оканчивается в хвосте (все узлы имеют искомое значение)**

```
        .....| 1 -> 1 -> 1 -> |.....

список значений узлов до удаления [1, 1, 1]
список значений после удаления первого найденного [1, 1]
список значений узлов после удаления всех узлов []

```

**Рассуждения**

Возможно, стоит рассматривать в рамках предыдущего случая (цепь продолжается до конца), т.к. данный сценарий характеризуется двумя условиями:
1) `curr_node is self.tail`, оно же `curr_node.next == None`
2) `prev_node == None` - т.к. вход в цепь узлов начинается с головы включительно, данное значение за цикл ни разу не обновляется 

**Код**

```python
# весь список состоит из совпадений
#...
curr_node = self.head
prev_node = None
while curr_node is not None: # проходим по каждому узлу, проверяя node.value
    if curr_node.value == val:
        if curr_node.next.value != val:
            if curr_node.next.value == None:
                if prev_node == None:
                    self.clean() # удаляем каждый узел, т.е. получаем пустой связный список
                else: # цепь начинается внутри списка и продолжается до конца (см. предыдущий сценарий)
                    prev_node.next = None
                    self.tail = prev_node
            else:
                ... # другие сценарии
        curr_node = corr_node.next

```

---

#### Этап 3: сборка метода.

**Код с комментариями**

```python
def delete(self, val, remove_all=True):
    curr_node = self.head
    prev_node = None
    while curr_node is not None: # проходим по каждому узлу, проверяя node.value
        if curr_node.value == val:

            # ---- цепь начинается с головы ------------------------------------------ 
            if curr_node.next.value != val:
                # if curr_node is self.head не подходит, т.к. после прохода по цепи self.tail != curr_node
                if prev_node is None:
                    self.head = curr_node.next
                    # предыдущий же узел не обновляется, пока не пройдем всю цепь

                # узел в конце списка или цепь до конца списка
                elif curr_node is self.tail:
                    # ---- весь список состоит из совпадений ----
                    if prev_node == None:
                        self.clean() # удаляем каждый узел, т.е. получаем пустой связный список
                        break
                    prev_node.next = None
                    self.tail = prev_node
                    # корректно для обоих вариантов
                    # .....| 0 -> 0 -> 0 -> 0 -> 1 |.....
                    # .....| 0 -> 0 -> 0 -> 0 -> 1 -> 1 -> 1 |.. вариант для remove_all=False прописан в curr_node.next.value == val
                                                                    # curr_node.value == val, curr_node.next.value == val
                else: # узел или цепь внутри списка
                    prev_node.next = curr_node.next
                    if remove_all == False:
                        break

            else: # curr_node.next.value == val
                if remove_all == False:
                    if prev_node is None:
                        self.head = curr_node.next
                    else:
                        prev_node.next = curr_node.next
                    break
            
        else:
            prev_node = curr_node # обновляем предыдущий узел, т.к. значение текущего не совпадает с искомым
        
        curr_node = curr_node.next
```

**Итоговая версия после отладки**

```python
    # ------------------------------------------------------------------------------------------------------------------
    def delete(self, val, remove_all=True):
        curr_node = self.head
        prev_node = None
        while curr_node is not None: # проходим по каждому узлу, проверяя node.value
            if curr_node.value == val:
                # ---- узел в конце списка или цепь до конца списка ----
                if curr_node is self.tail:
                    if prev_node == None: # ---- весь список состоит из совпадений ----
                        self.clean()
                        break
                    prev_node.next = None
                    self.tail = prev_node
                elif curr_node.next.value != val:
                    # ---- цепь начинается с головы ----
                    if prev_node is None:
                        self.head = curr_node.next
                    else: # ---- узел или цепь внутри списка ----
                        prev_node.next = curr_node.next
                        if remove_all == False:
                            break
                else: # curr_node.next.value == val
                    if remove_all == False:
                        if prev_node is None:
                            self.head = curr_node.next
                        else:
                            prev_node.next = curr_node.next
                        break
            else: # curr_node.value != val
                prev_node = curr_node
            curr_node = curr_node.next
    # ------------------------------------------------------------------------------------------------------------------
```
